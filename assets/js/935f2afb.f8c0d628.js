"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Prolog","href":"/signalstory/docs/prolog","docId":"prolog"},{"type":"link","label":"Installation","href":"/signalstory/docs/installation","docId":"installation"},{"type":"link","label":"Store","href":"/signalstory/docs/store","docId":"store"},{"type":"link","label":"Configuration","href":"/signalstory/docs/configuration","docId":"configuration"},{"type":"link","label":"Immutable Store","href":"/signalstory/docs/immutable-store","docId":"immutable-store"},{"type":"category","label":"Building Blocks","collapsible":true,"collapsed":false,"items":[{"type":"link","label":"Query","href":"/signalstory/docs/building-blocks/query","docId":"building-blocks/query"},{"type":"link","label":"Command","href":"/signalstory/docs/building-blocks/command","docId":"building-blocks/command"},{"type":"link","label":"Effect","href":"/signalstory/docs/building-blocks/effect","docId":"building-blocks/effect"},{"type":"link","label":"Event","href":"/signalstory/docs/building-blocks/event","docId":"building-blocks/event"}],"href":"/signalstory/docs/category/building-blocks"},{"type":"link","label":"Local state","href":"/signalstory/docs/local-state","docId":"local-state"},{"type":"category","label":"Plugins","collapsible":true,"collapsed":false,"items":[{"type":"link","label":"History","href":"/signalstory/docs/plugins/history","docId":"plugins/history"},{"type":"link","label":"Persistence","href":"/signalstory/docs/plugins/persistence","docId":"plugins/persistence"},{"type":"link","label":"DevTools","href":"/signalstory/docs/plugins/devtools","docId":"plugins/devtools"},{"type":"link","label":"Custom","href":"/signalstory/docs/plugins/custom-plugin","docId":"plugins/custom-plugin"}],"href":"/signalstory/docs/category/plugins"}]},"docs":{"building-blocks/command":{"id":"building-blocks/command","title":"Command","description":"Commands are the only actions that may modify the state of a store. They are exposed via functions set, update, and mutate to perform state modifications. All of those are based on the native signal modification functions.","sidebar":"tutorialSidebar"},"building-blocks/effect":{"id":"building-blocks/effect","title":"Effect","description":"Effects are basically side effects involving other entities and systems outside the regular flow that may affect the store. They are typically used for handling asynchronous operations, like making HTTP calls, that have an impact on the store\'s state.","sidebar":"tutorialSidebar"},"building-blocks/event":{"id":"building-blocks/event","title":"Event","description":"By utilizing events and event handlers, you can establish communication between stores, propagate side effect results, and coordinate actions across different parts of your application. This decoupled approach enables a more modular and flexible architecture, allowing for better maintainability and extensibility of your Angular application.","sidebar":"tutorialSidebar"},"building-blocks/query":{"id":"building-blocks/query","title":"Query","description":"Queries are used to retrieve data from the store\'s state. They represent read-only operations that fetch specific information from the state and make it available for consumption in other parts of the application.","sidebar":"tutorialSidebar"},"configuration":{"id":"configuration","title":"Configuration","description":"The store configuration allows you to customize the behavior of your store. The configuration is applied by passing it to the constructor. Since signalstory is a multi store state management library, each store can have its own configuration.","sidebar":"tutorialSidebar"},"immutable-store":{"id":"immutable-store","title":"Immutable Store","description":"Immutability has gained significant attention for its capacity to streamline state management, heighten predictability, and refine debugging processes. Particularly noteworthy is its conventional integration with the OnPush change detection strategy where immutable input objects have proved to accelerate performance in complex angular applications. Furthermore, immutability is a core principle in redux and the defining fundament of unidirectional data flow.","sidebar":"tutorialSidebar"},"installation":{"id":"installation","title":"Installation","description":"signalstory is based on signal, and hence requires at least angular 16.0","sidebar":"tutorialSidebar"},"local-state":{"id":"local-state","title":"Local state","description":"State management becomes even more challenging when dealing with the combination of domain data and UI-related state. This is a common scenario in modern web applications, where data fetched from backend services needs to be presented and interacted with in the user interface.","sidebar":"tutorialSidebar"},"plugins/custom-plugin":{"id":"plugins/custom-plugin","title":"Custom","description":"Custom plugins allow you to integrate additional behaviors to stores. You can design plugins that perform targeted tasks, integrating external services, validating inputs, or enhancing data management in any other way. This flexibility ensures that your store aligns perfectly with your application\'s unique use cases.","sidebar":"tutorialSidebar"},"plugins/devtools":{"id":"plugins/devtools","title":"DevTools","description":"Enhance your store\'s monitoring and debugging capabilities by leveraging the DevTools plugin in signalstory which integrates your store with the Redux DevTools browser extensions, enabling you to closely observe and analyze state changes.","sidebar":"tutorialSidebar"},"plugins/history":{"id":"plugins/history","title":"History","description":"signalstory provides a convenient way for consumers to access and navigate the state history of a store. By enabling the StoreHistoryPlugin, you can unlock powerful features such as undo and redo functionality and gain insights into the sequence of actions that have occurred within your application.","sidebar":"tutorialSidebar"},"plugins/persistence":{"id":"plugins/persistence","title":"Persistence","description":"signalstory provides a convenient mechanism for persisting the state of your store, allowing you to save and load the state across different sessions or browser refreshes. By enabling the StorePersistencePlugin, you can ensure that your store\'s state remains persistent and readily available.","sidebar":"tutorialSidebar"},"prolog":{"id":"prolog","title":"Prolog","description":"In the ever-evolving landscape of state management, developers have been confronted with the challenge of effectively managing state. Over time, various techniques based on local state, singletons, and services have been explored to tackle this challenge. However, as applications grow in complexity, these approaches have revealed limitations in terms of scalability, testability, and code organization.","sidebar":"tutorialSidebar"},"store":{"id":"store","title":"Store","description":"signalstory provides a powerful and flexible way to manage the state of your Angular application through its store implementation. Stores serve as a central hub for managing the application\'s state and facilitating state changes.","sidebar":"tutorialSidebar"}}}')}}]);