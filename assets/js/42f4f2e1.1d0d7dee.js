"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[593],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>g});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),d=i,g=u["".concat(l,".").concat(d)]||u[d]||m[d]||a;return n?r.createElement(g,o(o({ref:t},c),{},{components:n})):r.createElement(g,o({ref:t},c))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<a;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8722:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var r=n(7462),i=(n(7294),n(3905));const a={sidebar_position:5},o="Immutable Store",s={unversionedId:"immutable-store",id:"immutable-store",title:"Immutable Store",description:"Immutability has gained significant attention for its capacity to streamline state management, heighten predictability, and refine debugging processes. Particularly noteworthy is its conventional integration with the OnPush change detection strategy where immutable input objects have proved to accelerate performance in complex angular applications. Furthermore, immutability is a core principle in redux and the defining fundament of unidirectional data flow.",source:"@site/docs/immutable-store.md",sourceDirName:".",slug:"/immutable-store",permalink:"/signalstory/docs/immutable-store",draft:!1,editUrl:"https://github.com/zuriscript/signalstory/tree/master/docs/docs/immutable-store.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Configuration",permalink:"/signalstory/docs/configuration"},next:{title:"Building Blocks",permalink:"/signalstory/docs/category/building-blocks"}},l={},p=[{value:"The store",id:"the-store",level:2},{value:"Immutable type",id:"immutable-type",level:2},{value:"Immer.js",id:"immerjs",level:2}],c={toc:p},u="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"immutable-store"},"Immutable Store"),(0,i.kt)("p",null,"Immutability has gained significant attention for its capacity to streamline state management, heighten predictability, and refine debugging processes. Particularly noteworthy is its conventional integration with the ",(0,i.kt)("a",{parentName:"p",href:"https://angular.io/guide/change-detection-skipping-subtrees"},"OnPush change detection strategy")," where immutable input objects have proved to accelerate performance in complex angular applications. Furthermore, immutability is a core principle in redux and the defining fundament of unidirectional data flow."),(0,i.kt)("p",null,"There have been ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/angular/angular/pull/49644"},"experiments")," to introduce immutability directly into signals. However, this approach has been set aside as the associated drawbacks outweigh the potential advantages. Considering the wide-ranging applications of signals, we believe that incorporating immutability into store management could offer substantial gains in terms of safety and predictability."),(0,i.kt)("p",null,"For example, this is possible with signals:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const sig = signal({ property: 'initial' }).asReadonly();\nsig().property = 'new';\nconsole.log(sig()); // prints \"{ property: 'new' }\"\n")),(0,i.kt)("p",null,"Hence we can update the signal from everywhere without using ",(0,i.kt)("inlineCode",{parentName:"p"},"set"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"update"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"mutate")," and even without holding the reference to the actual ",(0,i.kt)("inlineCode",{parentName:"p"},"WritableSignal"),"."),(0,i.kt)("h2",{id:"the-store"},"The store"),(0,i.kt)("p",null,"An immutable store works same as a regular store, but uses a different base class:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"// highlight-start\nclass MyImmutableStore extends ImmutableStore<MyState> {\n// highlight-end\n  constructor() {\n    super({\n        initialState: { ... },\n        name: 'My Store',\n        enableLogging: true,\n        plugins: [\n          useDevtools(),\n          useStoreHistory(),\n          useStorePersistence(),\n        ],\n    });\n  }\n}\n\n")),(0,i.kt)("p",null,"You can also use it as dynamic store without declaring a class first:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const counterStore = new ImmutableStore<{ val: number }>({\n  initialState: { val: 5 },\n});\ncounterStore.mutate(state => state.val++, 'Increment');\nconsole.log(counterStore.state()); // prints \"{ val: 6 }\"\n")),(0,i.kt)("h2",{id:"immutable-type"},"Immutable type"),(0,i.kt)("p",null,"The Immutable store wraps the state object inside a generic ",(0,i.kt)("inlineCode",{parentName:"p"},"Immutable<T>")," type which provides compile time deep immutability for any object type. Notice however, that the state object is not deep freezed at runtime, hence, one could use type assertions to trick the compiler. It is in the responsebility of the developer to use or not to use this bypass."),(0,i.kt)("h2",{id:"immerjs"},"Immer.js"),(0,i.kt)("p",null,"The default implementation for producing immutable state is a naive json stringify/parse algorithm. The user is expected to pass a more sophisticated implementation from libraries like ",(0,i.kt)("a",{parentName:"p",href:"https://immerjs.github.io/immer/"},"immer.js")," or ",(0,i.kt)("a",{parentName:"p",href:"https://giusepperaso.github.io/structura.js/"},"structura.js"),".\nHere is an example using immer:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"// highlight-start\nimport { produce } from 'immer';\n// highlight-end\n\nclass MyImmerStore extends ImmutableStore<MyState> {\n  constructor() {\n    super({\n        initialState: { ... },\n        name: 'My Immmer Store',\n        // highlight-start\n        cloneAndMutateFunc: produce,\n        // highlight-end\n    });\n  }\n}\n")))}m.isMDXComponent=!0}}]);