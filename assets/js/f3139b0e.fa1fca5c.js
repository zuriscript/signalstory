"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[872],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>g});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},s=Object.keys(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=i.createContext({}),l=function(e){var t=i.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=l(e.components);return i.createElement(c.Provider,{value:t},e.children)},f="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,c=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),f=l(n),d=a,g=f["".concat(c,".").concat(d)]||f[d]||p[d]||s;return n?i.createElement(g,r(r({ref:t},u),{},{components:n})):i.createElement(g,r({ref:t},u))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,r=new Array(s);r[0]=d;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o[f]="string"==typeof e?e:a,r[1]=o;for(var l=2;l<s;l++)r[l]=n[l];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9554:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var i=n(7462),a=(n(7294),n(3905));const s={sidebar_position:2},r="Store Status",o={unversionedId:"plugins/status",id:"plugins/status",title:"Store Status",description:"Enable your store to track the loading, initialization and modification status. By utilizing the StoreStatusPlugin, you can monitor whether your store is currently loading (running an effect) and if it has been initialized or modified.",source:"@site/docs/plugins/status.md",sourceDirName:"plugins",slug:"/plugins/status",permalink:"/signalstory/docs/plugins/status",draft:!1,editUrl:"https://github.com/zuriscript/signalstory/tree/master/docs/docs/plugins/status.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Persistence",permalink:"/signalstory/docs/plugins/persistence"},next:{title:"Deep Freeze",permalink:"/signalstory/docs/plugins/deep-freeze"}},c={},l=[{value:"Enabling Store Status",id:"enabling-store-status",level:2},{value:"Supported Effect Types",id:"supported-effect-types",level:2},{value:"Considerations for Synchronous Effects",id:"considerations-for-synchronous-effects",level:4},{value:"Limitations with Effects Using in-function-scope Subscribed Observables",id:"limitations-with-effects-using-in-function-scope-subscribed-observables",level:4},{value:"Tracking Running Effects",id:"tracking-running-effects",level:2},{value:"Check If Any Effect Is Running",id:"check-if-any-effect-is-running",level:3},{value:"Checking If a Specific Effect Is Running",id:"checking-if-a-specific-effect-is-running",level:3},{value:"Manually Marking as Having No Running Effects",id:"manually-marking-as-having-no-running-effects",level:3},{value:"Tracking Loading Status",id:"tracking-loading-status",level:2},{value:"Tracking Initialization Status",id:"tracking-initialization-status",level:2},{value:"Tracking Modification Status",id:"tracking-modification-status",level:2},{value:"Reset store status",id:"reset-store-status",level:2}],u={toc:l},f="wrapper";function p(e){let{components:t,...n}=e;return(0,a.kt)(f,(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"store-status"},"Store Status"),(0,a.kt)("p",null,"Enable your store to track the loading, initialization and modification status. By utilizing the ",(0,a.kt)("inlineCode",{parentName:"p"},"StoreStatusPlugin"),", you can monitor whether your store is currently loading (running an effect) and if it has been initialized or modified."),(0,a.kt)("h2",{id:"enabling-store-status"},"Enabling Store Status"),(0,a.kt)("p",null,"To activate the store status tracking feature in signalstory, include the plugin using the exposed ",(0,a.kt)("inlineCode",{parentName:"p"},"useStoreStatus")," factory method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"class StoreWithStatus extends Store<MyState> {\n  constructor() {\n    super({\n      initialState: { ... },\n      name: 'My Store with Status',\n      plugins: [\n        useStoreStatus()\n      ],\n    });\n  }\n}\n")),(0,a.kt)("h2",{id:"supported-effect-types"},"Supported Effect Types"),(0,a.kt)("p",null,"This plugin works only with ",(0,a.kt)("a",{parentName:"p",href:"/signalstory/docs/building-blocks/effect#effect-objects"},"effects objects"),". Generally, it works well with effects that return observables or promises which makes it particularly useful when dealing with asynchronous operations such as HTTP calls or other asynchronous tasks that modify or retrieve information from a store's state."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Effect returning Observables"),": The plugin can monitor the loading status and modification status of the store during the asynchronous execution of the observable. It works even if the effect's observable encounters errors, uses the filter operator, or operates as a hot observable (i.e., a subject)."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const myObservableEffect = createEffect(\n  'My Observable Effect',\n  (store, params) => {\n    return inject(MyService)\n      .getData(params)\n      .pipe(\n        tap(data => {\n          store.set(data, 'Data Loaded');\n        })\n      );\n  }\n);\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Effect returning Promises"),": the plugin fully supports effects that return promises, whether utilizing an async block or directly returning a promise."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"// Example of using a promise in an effect\nconst myPromiseEffect = createEffect(\n  'My Promise Effect',\n  async (store, params) => {\n    const data = await inject(MyService).getData(params);\n    store.set(data, 'Data Loaded');\n  }\n);\n")))),(0,a.kt)("h4",{id:"considerations-for-synchronous-effects"},"Considerations for Synchronous Effects"),(0,a.kt)("p",null,"While the Store Status Plugin can technically work with synchronous effects, it's essential to know that change detection doesn't run during their execution. As a result, consumers won't be notified of status changes, making status tracking less beneficial for synchronous effects."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"If you have a specific need to track status in synchronous effects, signalstory could potentially provide a solution by scheduling such effects using the macrotask queue. This approach introduces a slight delay in the execution of the effect, but it ensures the ability to notify consumers about status changes. Feel free to raise a request on GitHub for us to further explore and consider this implementation.")),(0,a.kt)("h4",{id:"limitations-with-effects-using-in-function-scope-subscribed-observables"},"Limitations with Effects Using in-function-scope Subscribed Observables"),(0,a.kt)("p",null,"If an effect contains an observable that is subscribed to within the effect function scope, the Store Status Plugin may not work as expected. This is because the plugin does not have information about the observable and cannot hook into its execution. In such cases, it's advisable to structure the effect to avoid subscribing to observables within the effect function."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const myNotSoObservableEffect = createEffect(\n  'My not so observable Effect',\n  (store, params) => {\n    inject(MyService)\n      .getData(params)\n      .subscribe(data => {\n        store.set(data, 'Data Loaded');\n      });\n  }\n);\n")),(0,a.kt)("h2",{id:"tracking-running-effects"},"Tracking Running Effects"),(0,a.kt)("h3",{id:"check-if-any-effect-is-running"},"Check If Any Effect Is Running"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"isAnyEffectRunning")," function returns a Signal indicating whether any effect is currently running for any of the provided stores. If no stores are provided, it returns a signal indicating if any store has an effect running."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const anyEffectRunningSignal = isAnyEffectRunning(); // returns true if any store has any effect running\nconst singleEffectRunningSignal = isAnyEffectRunning(store); // returns true if the given store has any effect running\nconst multipleEffectRunningSignal = isAnyEffectRunning(store1, store2); // returns true if store1 or store2 has any effect running\n")),(0,a.kt)("h3",{id:"checking-if-a-specific-effect-is-running"},"Checking If a Specific Effect Is Running"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"isEffectRunning")," function returns a Signal indicating whether the specified effect is currently running for any of the provided stores. If no stores are provided, it returns a signal indicating if any store has the given effect running."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const anyEffectRunningSignal = isEffectRunning(effect); // returns true if any store has the specified effect running\nconst singleEffectRunningSignal = isEffectRunning(effect, store); // returns true if the given store has the specified effect running\nconst multipleEffectRunningSignal = isEffectRunning(effect, store1, store2); // returns true if store1 or store2 has the specified effect running\n")),(0,a.kt)("h3",{id:"manually-marking-as-having-no-running-effects"},"Manually Marking as Having No Running Effects"),(0,a.kt)("p",null,"It should not happen but in rare situations where an effect is not automatically removed from the running state, you can manually mark a store as not having any running effects using the ",(0,a.kt)("inlineCode",{parentName:"p"},"markAsHavingNoRunningEffects")," function."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"markAsHavingNoRunningEffects(store);\n")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"If you encounter such a situation, use this method as a temporary workaround and be sure to file an issue on GitHub for further investigation and resolution.")),(0,a.kt)("h2",{id:"tracking-loading-status"},"Tracking Loading Status"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"isLoading")," function provides a Signal indicating whether any of the specified stores is currently in a loading state. If no stores are provided, it returns a signal indicating if any store is in a loading state. This is a specialized feature of the prior section: Instead of tracking any running effect, it is scoped to marked effects."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const anyLoadingSignal = isLoading(); // returns true if any store is loading\nconst singelLoadingSignal = isLoading(store); // returns true if the given store is loading\nconst multipleLoadingSignal = isLoading(store1, store2); // returns true if store1 or store2 is loading\n")),(0,a.kt)("p",null,"An effect created with ",(0,a.kt)("inlineCode",{parentName:"p"},"setLoadingStatus")," will mark the associated store as loading while the effect is running."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const effectThatLoadsBooks = createEffect(\n  'Load Books',\n  (store: BookStore): Observable<unknown> => {\n    return inject(BookService);\n    loadBooks().pipe(tap(books => store.setBookData(books.items)));\n  },\n  // highlight-start\n  {\n    setLoadingStatus: true,\n  }\n  // highlight-end\n);\n")),(0,a.kt)("h2",{id:"tracking-initialization-status"},"Tracking Initialization Status"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"initialized")," function returns a Signal indicating whether the specified store has been initialized by an initializing effect."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const initializedSignal = initialized(store);\n")),(0,a.kt)("p",null,"A store is initially ",(0,a.kt)("strong",{parentName:"p"},"not initialized")," and any command (",(0,a.kt)("inlineCode",{parentName:"p"},"set"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"update"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"mutate"),") applied to the store will not change this status.\nOnly an effect created with the ",(0,a.kt)("inlineCode",{parentName:"p"},"setInitializedStatus")," flag can set the store's initialization status to ",(0,a.kt)("strong",{parentName:"p"},"initialized"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const effectThatInitializesStore = createEffect(\n  'Load Books',\n  (store: BookStore): Observable<unknown> => {\n    return inject(BookService);\n    loadBooks().pipe(tap(books => store.setBookData(books.items)));\n  },\n  // highlight-start\n  {\n    setInitializedStatus: true,\n  }\n  // highlight-end\n);\n")),(0,a.kt)("h2",{id:"tracking-modification-status"},"Tracking Modification Status"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"modified")," function returns a Signal indicating whether the specified store has been modified."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const modifiedSignal = modified(store);\n")),(0,a.kt)("p",null,"A store is initially ",(0,a.kt)("strong",{parentName:"p"},"unmodified"),". Any command (",(0,a.kt)("inlineCode",{parentName:"p"},"set"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"update"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"mutate"),") applied to the store will mark it as ",(0,a.kt)("strong",{parentName:"p"},"modified"),". Additionally, an effect created with the ",(0,a.kt)("inlineCode",{parentName:"p"},"setInitializedStatus")," flag can reset the store's modification status back to ",(0,a.kt)("strong",{parentName:"p"},"unmodified"),"."),(0,a.kt)("h2",{id:"reset-store-status"},"Reset store status"),(0,a.kt)("p",null,"In some cases, it could be necessary to manually reset the store status to ",(0,a.kt)("inlineCode",{parentName:"p"},"unmodified")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"deinitialized")," using the ",(0,a.kt)("inlineCode",{parentName:"p"},"resetStoreStatus")," function."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"resetStoreStatus(store);\n")))}p.isMDXComponent=!0}}]);