"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Prolog","href":"/signalstory/docs/prolog","docId":"prolog"},{"type":"link","label":"Installation","href":"/signalstory/docs/installation","docId":"installation"},{"type":"link","label":"Store","href":"/signalstory/docs/store","docId":"store"},{"type":"link","label":"Configuration","href":"/signalstory/docs/configuration","docId":"configuration"},{"type":"category","label":"Building Blocks","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Query","href":"/signalstory/docs/building-blocks/query","docId":"building-blocks/query"},{"type":"link","label":"Command","href":"/signalstory/docs/building-blocks/command","docId":"building-blocks/command"},{"type":"link","label":"Effect","href":"/signalstory/docs/building-blocks/effect","docId":"building-blocks/effect"},{"type":"link","label":"Event","href":"/signalstory/docs/building-blocks/event","docId":"building-blocks/event"}],"href":"/signalstory/docs/category/building-blocks"},{"type":"link","label":"History","href":"/signalstory/docs/history","docId":"history"},{"type":"link","label":"Persistence","href":"/signalstory/docs/persistence","docId":"persistence"}]},"docs":{"building-blocks/command":{"id":"building-blocks/command","title":"Command","description":"Commands are the only actions that may modify the state of a store. They are exposed via functions set, update, and mutate to perform state modifications. All of those are based on the native signal modification functions.","sidebar":"tutorialSidebar"},"building-blocks/effect":{"id":"building-blocks/effect","title":"Effect","description":"Effects are basically side effects involving other entities and systems outside the regular flow that may affect the store. They are typically used for handling asynchronous operations, like making HTTP calls, that have an impact on the store\'s state.","sidebar":"tutorialSidebar"},"building-blocks/event":{"id":"building-blocks/event","title":"Event","description":"By utilizing events and event handlers, you can establish communication between stores, propagate side effect results, and coordinate actions across different parts of your application. This decoupled approach enables a more modular and flexible architecture, allowing for better maintainability and extensibility of your Angular application.","sidebar":"tutorialSidebar"},"building-blocks/query":{"id":"building-blocks/query","title":"Query","description":"Queries are used to retrieve data from the store\'s state. They represent read-only operations that fetch specific information from the state and make it available for consumption in other parts of the application.","sidebar":"tutorialSidebar"},"configuration":{"id":"configuration","title":"Configuration","description":"The store configuration allows you to customize the behavior of your store. It provides various options to tailor the store\'s functionality according to your specific requirements. The configuration is applied by passing it to the constructor. Since signalstory is a multi store state management library, each store can have its own configuration.","sidebar":"tutorialSidebar"},"history":{"id":"history","title":"History","description":"signalstory provides a convenient way for consumers to access and navigate the state history of a store. By enabling the enableStateHistory configuration option, you can unlock powerful features such as undo and redo functionality and gain insights into the sequence of actions that have occurred within your application.","sidebar":"tutorialSidebar"},"installation":{"id":"installation","title":"Installation","description":"signalstory is based on signal, and hence requires at least angular 16.0","sidebar":"tutorialSidebar"},"persistence":{"id":"persistence","title":"Persistence","description":"signalstory provides a convenient mechanism for persisting the state of your store, allowing you to save and load the state across different sessions or browser refreshes. By enabling the enableLocalStorageSync configuration option, you can ensure that your store\'s state remains persistent and readily available.","sidebar":"tutorialSidebar"},"prolog":{"id":"prolog","title":"Prolog","description":"In the ever-evolving landscape of state management, developers have been confronted with the challenge of effectively managing state. Over time, various techniques based on local state, singletons, and services have been explored to tackle this challenge. However, as applications grow in complexity, these approaches have revealed limitations in terms of scalability, testability, and code organization.","sidebar":"tutorialSidebar"},"store":{"id":"store","title":"Store","description":"signalstory provides a powerful and flexible way to manage the state of your Angular application through its store implementation. Stores serve as a central hub for managing the application\'s state and facilitating state changes.","sidebar":"tutorialSidebar"}}}')}}]);