"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[432],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>g});var r=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,r,s=function(e,t){if(null==e)return{};var n,r,s={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,s=e.mdxType,o=e.originalType,c=e.parentName,u=a(e,["components","mdxType","originalType","parentName"]),d=l(n),h=s,g=d["".concat(c,".").concat(h)]||d[h]||p[h]||o;return n?r.createElement(g,i(i({ref:t},u),{},{components:n})):r.createElement(g,i({ref:t},u))}));function g(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=n.length,i=new Array(o);i[0]=h;var a={};for(var c in t)hasOwnProperty.call(t,c)&&(a[c]=t[c]);a.originalType=e,a[d]="string"==typeof e?e:s,i[1]=a;for(var l=2;l<o;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},4534:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var r=n(7462),s=(n(7294),n(3905));const o={sidebar_position:10},i="Testing",a={unversionedId:"testing",id:"testing",title:"Testing",description:"Stores are injectable services and can be unit-tested in isolation, much like any other service. You can directly instantiate a store class or use TestBed if your store class has dependencies and you prefer managing them within an injection context during tests. While services can often be tested unmocked as part of the component, it's highly beneficial to conduct unit tests on the store in isolation.",source:"@site/docs/testing.md",sourceDirName:".",slug:"/testing",permalink:"/signalstory/docs/testing",draft:!1,editUrl:"https://github.com/zuriscript/signalstory/tree/master/docs/docs/testing.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10},sidebar:"tutorialSidebar",previous:{title:"State Snapshot",permalink:"/signalstory/docs/state-snapshot"},next:{title:"Howto",permalink:"/signalstory/docs/Howto"}},c={},l=[{value:"Testing Commands",id:"testing-commands",level:2},{value:"Testing Queries",id:"testing-queries",level:2},{value:"Testing Effect objects",id:"testing-effect-objects",level:2},{value:"Testing Query objects",id:"testing-query-objects",level:2},{value:"Testing Events",id:"testing-events",level:2}],u={toc:l},d="wrapper";function p(e){let{components:t,...n}=e;return(0,s.kt)(d,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"testing"},"Testing"),(0,s.kt)("p",null,"Stores are injectable services and can be unit-tested in isolation, much like any other service. You can directly instantiate a store class or use ",(0,s.kt)("a",{parentName:"p",href:"https://angular.io/api/core/testing/TestBed"},"TestBed")," if your store class has dependencies and you prefer managing them within an injection context during tests. While services can often be tested unmocked as part of the component, it's highly beneficial to conduct unit tests on the store in isolation."),(0,s.kt)("p",null,"For testing effect and query objects, signalstory provides utility methods under ",(0,s.kt)("inlineCode",{parentName:"p"},"signalstory/testing"),", offering a more readable and targeted syntax than using ",(0,s.kt)("inlineCode",{parentName:"p"},"TestBed")," as-is."),(0,s.kt)("p",null,"There are lot of strategies and flavours for unit testing services, or unit testing per se. Following sections will demonstrate some strategies for testing different store aspects using ",(0,s.kt)("a",{parentName:"p",href:"https://jestjs.io/"},"jest"),", although any other testing and mocking framework may work here."),(0,s.kt)("p",null,"For demonstration, following store class will be used."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"interface User {\n  id: string;\n  name: string;\n}\n\nclass UserStore extends Store<User[]> {\n  constructor() {\n    super({ initialState: [] });\n  }\n\n  get names() {\n    return computed(() => this.state().map(x => x.name));\n  }\n\n  addUser(name: string) {\n    this.mutate(state => state.push({ id: Math.random().toString(), name }));\n  }\n}\n")),(0,s.kt)("h2",{id:"testing-commands"},"Testing Commands"),(0,s.kt)("p",null,"Commands modify the store's state without causing side effects. Consequently, testing them is relatively straightforward: just confirm that the specified input results in the intended state. In cases where the command logic is complex or involves business logic, we would want to check known edge cases specifically."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"describe('addUser', () => {\n  it('should create User', () => {\n    // arrange\n    const store = new UserStore();\n    const userName = 'Mike';\n\n    // act\n    store.addUser(userName);\n\n    // assert\n    expect(store.state()).toEqual([\n      {\n        id: expect.any(String),\n        name: userName,\n      },\n    ]);\n  });\n});\n")),(0,s.kt)("p",null,"Note, that here we are creating the store as part of the test case. This could also be accomplished in the ",(0,s.kt)("inlineCode",{parentName:"p"},"beforeEach")," hook or entirely offloaded to fixture logic."),(0,s.kt)("h2",{id:"testing-queries"},"Testing Queries"),(0,s.kt)("p",null,"Queries retrieve data from the store while possibly applying transformation, filtering and aggreation logic. For queries we want to test that a given store state leads to the right query projection. Again, complex query logic should involve testing edge cases."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"describe('names', () => {\n  it('should return empty array if there are no Users', () => {\n    // arrange\n    const store = new UserStore();\n\n    // act\n    const result = store.names();\n\n    // assert\n    expect(result).toStrictEqual([]);\n  });\n  it('should return names of all users', () => {\n    // arrange\n    const store = new UserStore();\n    const names = ['Mike', 'Rowan', 'Sepp'];\n    names.forEach(name => store.addUser(name));\n\n    // act\n    const result = store.names();\n\n    // assert\n    expect(result).toStrictEqual(names);\n  });\n});\n")),(0,s.kt)("h2",{id:"testing-effect-objects"},"Testing Effect objects"),(0,s.kt)("p",null,"Effect objects encapsulate one or more actions associated with a store, potentially involving side effects. The store either provides data for or is on the receiving end of a state change resulting from the effect function, which runs in an injection context and is intended to utilize other services. Testing effects requires verifying that both the expected outcomes (",(0,s.kt)("inlineCode",{parentName:"p"},"happy paths"),") and errors (",(0,s.kt)("inlineCode",{parentName:"p"},"unhappy paths"),") lead to the correct state change of the store, as well as triggering the appropriate side effects in other parts of the application, if any."),(0,s.kt)("p",null,"Testing involves multiple scenarios, varying in the number of dependent services and responses they can return. It's advisable to prioritize using real implementations of dependencies over creating mocks. Mocks should be used to mimic the correct service interaction, prompting a specific path for testing. While ",(0,s.kt)("inlineCode",{parentName:"p"},"TestBed")," can be utilized for managing dependencies, signalstory stores have their own injection context reference, allowing for the isolation of the test DI context on the store."),(0,s.kt)("p",null,"Let's look at following effect object:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"export const fetchUsersEffect = createEffect(\n  'Fetch Users',\n  (store: UserStore) => {\n    const service = inject(UserService);\n    const notification = inject(NotificationService);\n\n    return service.fetchUsers().pipe(\n      catchError(err => {\n        notification.alertError(err);\n        return of([]);\n      }),\n      tap(result => store.set(result, 'Load Users from Backend'))\n    );\n  }\n);\n")),(0,s.kt)("p",null,"The tests could look like:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"import {\n  configureInjectionContext,\n  getFromStoreInjector,\n} from 'signalstory/testing';\n\ndescribe('fetchUsersEffect', () => {\n  it('should fill the store with users on successfull service response', async () => {\n    // arrange\n    const store = new UserStore();\n    const usersToBeFetched = [<User>{ id: '1', name: 'hans' }];\n    configureInjectionContext(store, opt =>\n      opt\n        .addMocked(UserService, service => {\n          service.fetchUsers = jest.fn(() => of(usersToBeFetched));\n        })\n        .addRegular(NotificationService)\n    );\n\n    // act\n    await lastValueFrom(store.runEffect(fetchUsersEffect));\n\n    // assert\n    expect(store.state()).toBe(usersToBeFetched);\n  });\n\n  it('should empty store on error response', async () => {\n    // arrange\n    const store = new UserStore();\n    configureInjectionContext(store, opt =>\n      opt\n        .addMocked(UserService, service => {\n          service.fetchUsers = jest.fn(() =>\n            throwError(() => new Error('Http Error'))\n          );\n        })\n        .addMocked(NotificationService, service => {\n          service.alertError = jest.fn();\n        })\n    );\n\n    // act\n    await lastValueFrom(store.runEffect(fetchUsersEffect));\n\n    // assert\n    expect(store.state()).toEqual([]);\n    expect(\n      getFromStoreInjector(store, NotificationService)?.alertError\n    ).toHaveBeenCalledTimes(1);\n  });\n});\n")),(0,s.kt)("p",null,"In the ",(0,s.kt)("inlineCode",{parentName:"p"},"happy path"),", we're checking that when we successfully call the user backend to grab users, our store gets filled up with them. To pull this off, we use ",(0,s.kt)("inlineCode",{parentName:"p"},"configureInjectionContext")," to mock the user service, making it return a fixed list of users. Since the effect function doesn't mess with the notification service when everything goes smoothly, we simply register the notification service unmocked in the dependency injection."),(0,s.kt)("p",null,"Now, on the ",(0,s.kt)("inlineCode",{parentName:"p"},"unhappy path"),", our focus shifts to testing how the system responds when the user backend call encounters issues. We want to ensure that in such scenarios, not only does it reset the user store, but it also uses the notification service to trigger an alert function. Hence, We register a mock for the user service that throws an error upon function call, and then, we mock the specific function of the notification service to confirm its invocation."),(0,s.kt)("h2",{id:"testing-query-objects"},"Testing Query objects"),(0,s.kt)("p",null,"Query objects that target multiple stores involve a bit more complexity when it comes to testing. It requires exploring various combinations of initial states and diverse transformation and joining logic across different stores."),(0,s.kt)("p",null,"To illustrate, let's introduce another store:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"interface Order {\n  id: string | undefined;\n  userId: string;\n  product: string;\n}\n\nclass OrderStore extends Store<Order[]> {\n  constructor() {\n    super({ initialState: [] });\n  }\n\n  placeOrder(userId: string, product: string) {\n    this.mutate(state =>\n      state.push({\n        id: undefined,\n        product,\n        userId,\n      })\n    );\n  }\n\n  hasUserPlacedOrder(userId: string) {\n    return this.state().some(order => order.userId === userId);\n  }\n}\n")),(0,s.kt)("p",null,"Now, envision a query object that targets both the user service and the order service, resembling:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"export const userWithOrdersQuery = createQuery(\n  [OrderStore, UserStore],\n  (orders, users) =>\n    users.state().filter(x => x.id && orders.hasUserPlacedOrder(x.id))\n);\n")),(0,s.kt)("p",null,"A potential test case might be:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"describe('userWithOrdersQuery', () => {\n  it('should return users with orders', () => {\n    // arrange\n    const userStore = new UserStore();\n    const users = ['Mike', 'Daniel', 'Michael'];\n    users.forEach(user => userStore.addUser(user));\n\n    const orderStore = new OrderStore();\n    const usersWithOrders = userStore.state().slice(0, 2);\n    orderStore.placeOrder(usersWithOrders[0].id, 'Banana');\n    orderStore.placeOrder(usersWithOrders[1].id, 'Apple');\n\n    configureInjectionContext(orderStore, opt =>\n      opt.addExisting(UserStore, userStore)\n    );\n\n    // act\n    const result = orderStore.runQuery(userWithOrdersQuery)();\n\n    // assert\n    expect(result).toStrictEqual(usersWithOrders);\n  });\n});\n")),(0,s.kt)("p",null,"In preparation for the test case, we set up both stores beforehand and register the prepared instance of the user store in the injection context of the order store. No mocking occurs in this scenario."),(0,s.kt)("h2",{id:"testing-events"},"Testing Events"),(0,s.kt)("p",null,"An event involves one producer/publisher and can involve an arbitrary number of handling stores. Since producers are typically unaware of which stores (handlers) are reacting to their events, this principle should guide our testing strategy: Test the producing side and each handler independently, each with its unique edge cases and context. This approach ensures our testing code stays neat and tidy, dealing with the context of one side at a time."),(0,s.kt)("p",null,"Let's craft an event and have the user store publish it in a new command:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"export const userRemovedEvent = createEvent<{ id: string }>('User removed');\n\n// Following is inside the user store\nremoveUser(userId: string) {\n  this.update(state => state.filter(x => x.id !== userId));\n  publishStoreEvent(userRemovedEvent, { id: userId });\n}\n")),(0,s.kt)("p",null,"Now, let's bring in the order store as a handler. Typically, the registration occurs within the store constructors, although it could also take place in other locations:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"this.registerHandler(userRemovedEvent, (store, event) => {\n  this.update(state => state.filter(o => o.userId !== event.payload!.id));\n});\n")),(0,s.kt)("p",null,"Ensuring the producing side is on track means making sure the right process publishes the correct event:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"it('should remove user and publish store event', () => {\n  // arrange\n  const store = new UserStore();\n  store.addUser('Mike');\n  const handler = jest.fn();\n  store.registerHandler(userRemovedEvent, handler);\n\n  // act\n  store.removeUser(store.state()[0].id);\n\n  // assert\n  expect(store.state()).toStrictEqual([]);\n  expect(handler).toHaveBeenCalledTimes(1);\n});\n")),(0,s.kt)("p",null,"Now we have to make sure that the handling store effectively responds to the specific event in the correct way."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"it('should handle userRemovedEvent and remove user', () => {\n  // arrange\n  const store = new OrderStore();\n  const userId = '1234';\n  store.placeOrder(userId, 'Avocado');\n\n  // act\n  publishStoreEvent(userRemovedEvent, { id: userId });\n\n  // assert\n  expect(store.state()).toStrictEqual([]);\n});\n")))}p.isMDXComponent=!0}}]);